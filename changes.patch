diff --git a/src/controllers/CourseController.ts b/src/controllers/CourseController.ts
index 22e410b..d27e7ea 100644
--- a/src/controllers/CourseController.ts
+++ b/src/controllers/CourseController.ts
@@ -128,6 +128,36 @@ class CourseController {
         reply.status(200).send(courseSerializer.serialize(updatedCourse));
     }
 
+    async getUserBookmarkedCourses(request: FastifyRequest, reply: FastifyReply) {
+        const queryParamsValidator = z.object({
+            languageCode: languageCodeValidator.optional(),
+            addedBy: usernameValidator.or(z.literal("me")).optional(),
+            searchQuery: z.string().max(256).optional(),
+            sortBy: z.union([z.literal("title"), z.literal("createdDate"), z.literal("avgPastViewersCountPerLesson")]).optional().default("title"),
+            sortOrder: z.union([z.literal("asc"), z.literal("desc")]).optional().default("asc"),
+            page: z.coerce.number().int().min(1).optional().default(1),
+            pageSize: z.coerce.number().int().min(1).max(100).optional().default(10),
+        });
+        const queryParams = queryParamsValidator.parse(request.query);
+        if (queryParams.addedBy == "me")
+            queryParams.addedBy = request.user!.username;
+        const filters = {
+            languageCode: queryParams.languageCode,
+            addedBy: queryParams.addedBy,
+            searchQuery: queryParams.searchQuery,
+            isBookmarked: true
+        };
+        const sort = {sortBy: queryParams.sortBy, sortOrder: queryParams.sortOrder};
+        const pagination = {page: queryParams.page, pageSize: queryParams.pageSize};
+        const courseService = new CourseService(request.em);
+        const [courses, recordsCount] = await courseService.getPaginatedCourses(filters, sort, pagination, request.user);
+        reply.send({
+            page: pagination.page,
+            pageSize: pagination.pageSize,
+            pageCount: Math.ceil(recordsCount / pagination.pageSize),
+            data: courseSerializer.serializeList(courses)
+        });
+    }
 }
 
 export default new CourseController();
diff --git a/src/controllers/LessonController.ts b/src/controllers/LessonController.ts
index a1a5978..997a9fb 100644
--- a/src/controllers/LessonController.ts
+++ b/src/controllers/LessonController.ts
@@ -146,6 +146,7 @@ class LessonController {
 
     }
 
+    //TODO show deleted and privated lessons as deleted and privated lessons instead of hiding them. Do this with bookmarked courses as well
     async getUserLessonsHistory(request: FastifyRequest, reply: FastifyReply) {
         const pathParamsValidator = z.object({username: usernameValidator.or(z.literal("me"))});
         const pathParams = pathParamsValidator.parse(request.params);
diff --git a/src/migrations/.snapshot-dzelda-db.json b/src/migrations/.snapshot-dzelda-db.json
index 67104ac..e7e0d17 100644
--- a/src/migrations/.snapshot-dzelda-db.json
+++ b/src/migrations/.snapshot-dzelda-db.json
@@ -885,6 +885,89 @@
         }
       }
     },
+    {
+      "columns": {
+        "id": {
+          "name": "id",
+          "type": "int",
+          "unsigned": true,
+          "autoincrement": true,
+          "primary": true,
+          "nullable": false,
+          "mappedType": "integer"
+        },
+        "course_id": {
+          "name": "course_id",
+          "type": "int",
+          "unsigned": false,
+          "autoincrement": false,
+          "primary": false,
+          "nullable": false,
+          "mappedType": "integer"
+        },
+        "bookmarker_id": {
+          "name": "bookmarker_id",
+          "type": "int",
+          "unsigned": false,
+          "autoincrement": false,
+          "primary": false,
+          "nullable": false,
+          "mappedType": "integer"
+        }
+      },
+      "name": "map_bookmarker_course",
+      "schema": "public",
+      "indexes": [
+        {
+          "keyName": "map_bookmarker_course_course_id_bookmarker_id_unique",
+          "columnNames": [
+            "course_id",
+            "bookmarker_id"
+          ],
+          "composite": true,
+          "primary": false,
+          "unique": true
+        },
+        {
+          "keyName": "map_bookmarker_course_pkey",
+          "columnNames": [
+            "id"
+          ],
+          "composite": false,
+          "primary": true,
+          "unique": true
+        }
+      ],
+      "checks": [],
+      "foreignKeys": {
+        "map_bookmarker_course_course_id_foreign": {
+          "constraintName": "map_bookmarker_course_course_id_foreign",
+          "columnNames": [
+            "course_id"
+          ],
+          "localTableName": "public.map_bookmarker_course",
+          "referencedColumnNames": [
+            "id"
+          ],
+          "referencedTableName": "public.course",
+          "deleteRule": "cascade",
+          "updateRule": "cascade"
+        },
+        "map_bookmarker_course_bookmarker_id_foreign": {
+          "constraintName": "map_bookmarker_course_bookmarker_id_foreign",
+          "columnNames": [
+            "bookmarker_id"
+          ],
+          "localTableName": "public.map_bookmarker_course",
+          "referencedColumnNames": [
+            "id"
+          ],
+          "referencedTableName": "public.profile",
+          "deleteRule": "cascade",
+          "updateRule": "cascade"
+        }
+      }
+    },
     {
       "columns": {
         "id": {
diff --git a/src/models/entities/Course.ts b/src/models/entities/Course.ts
index f5c5940..a2a5701 100644
--- a/src/models/entities/Course.ts
+++ b/src/models/entities/Course.ts
@@ -1,10 +1,11 @@
-import {Collection, Entity, Formula, Index, ManyToOne, OneToMany, OptionalProps, Property, types} from "@mikro-orm/core";
+import {Collection, Entity, Formula, Index, ManyToMany, ManyToOne, OneToMany, OptionalProps, Property, types} from "@mikro-orm/core";
 import {CustomBaseEntity} from "@/src/models/entities/CustomBaseEntity.js";
 import {Language} from "@/src/models/entities/Language.js";
 import {Profile} from "@/src/models/entities/Profile.js";
 import {Lesson} from "@/src/models/entities/Lesson.js";
 import {VocabLevel} from "@/src/models/enums/VocabLevel.js";
 import {CourseRepo} from "@/src/models/repos/CourseRepo.js";
+import {MapBookmarkerCourse} from "@/src/models/entities/MapBookmarkerCourse.js";
 
 @Entity({customRepository: () => CourseRepo})
 @Index({properties: ["language"]})
@@ -37,7 +38,16 @@ export class Course extends CustomBaseEntity {
     @OneToMany({entity: () => Lesson, mappedBy: (lesson) => lesson.course})
     lessons: Collection<Lesson> = new Collection<Lesson>(this);
 
-    [OptionalProps]?: "description" | "image" | "isPublic" | "addedOn" | "avgPastViewersCountPerLesson";
+    @ManyToMany({
+        entity: () => Profile,
+        inversedBy: (user: Profile) => user.coursesBookmarked,
+        pivotEntity: () => MapBookmarkerCourse,
+        joinColumn: "course_id",
+        inverseJoinColumn: "bookmarker_id"
+    })
+    bookmarkers!: Profile;
+
+    [OptionalProps]?: "description" | "image" | "isPublic" | "addedOn" | "bookmarkers" | "avgPastViewersCountPerLesson";
 
     //annotated properties
     @Property({persist: false, type: types.json})
diff --git a/src/models/entities/MapBookmarkerCourse.ts b/src/models/entities/MapBookmarkerCourse.ts
index e69de29..8d5cf19 100644
--- a/src/models/entities/MapBookmarkerCourse.ts
+++ b/src/models/entities/MapBookmarkerCourse.ts
@@ -0,0 +1,14 @@
+import {Entity, ManyToOne, Unique} from "@mikro-orm/core";
+import {CustomBaseEntity} from "@/src/models/entities/CustomBaseEntity.js";
+import {Profile} from "@/src/models/entities/Profile.js";
+import {Course} from "@/src/models/entities/Course.js";
+
+@Entity()
+@Unique({properties: ["course", "bookmarker"]})
+export class MapBookmarkerCourse extends CustomBaseEntity {
+    @ManyToOne({entity: () => Course, onDelete: "cascade", onUpdateIntegrity: "cascade"})
+    course!: Course;
+
+    @ManyToOne({entity: () => Profile, onDelete: "cascade", onUpdateIntegrity: "cascade"})
+    bookmarker!: Profile;
+}
diff --git a/src/models/entities/Profile.ts b/src/models/entities/Profile.ts
index 83e9af1..69e2d7d 100644
--- a/src/models/entities/Profile.ts
+++ b/src/models/entities/Profile.ts
@@ -12,6 +12,7 @@ import {Dictionary} from "@/src/models/entities/Dictionary.js";
 import {MapLearnerDictionary} from "@/src/models/entities/MapLearnerDictionary.js";
 import {Language} from "@/src/models/entities/Language.js";
 import {MapLearnerLanguage} from "@/src/models/entities/MapLearnerLanguage.js";
+import {MapBookmarkerCourse} from "@/src/models/entities/MapBookmarkerCourse.js";
 
 @Entity()
 export class Profile extends CustomBaseEntity {
@@ -79,6 +80,14 @@ export class Profile extends CustomBaseEntity {
     })
     dictionariesSaved: Collection<Dictionary> = new Collection<Dictionary>(this);
 
+    @ManyToMany({
+        entity: () => Course,
+        mappedBy: (course: Course) => course.bookmarkers,
+        pivotEntity: () => MapBookmarkerCourse,
+        hidden: true
+    })
+    coursesBookmarked: Collection<Course> = new Collection<Course>(this);
+
     @OneToMany({entity: () => Course, mappedBy: (course: Course) => course.addedBy, hidden: true})
     coursesAdded: Collection<Course> = new Collection<Course>(this);
 
diff --git a/src/routers/coursesRouter.ts b/src/routers/coursesRouter.ts
index c464d45..7f24e90 100644
--- a/src/routers/coursesRouter.ts
+++ b/src/routers/coursesRouter.ts
@@ -23,5 +23,10 @@ export const coursesRouter: FastifyPluginCallback = function (fastify, options,
         onResponse: deleteFileOnFail
     });
 
+    fastify.get(`/user/me/courses/bookmarked/`, {
+        preHandler: [requiresAuth, requiresEmailConfirmed],
+        handler: CourseController.getUserBookmarkedCourses,
+    });
+
     done();
 };
diff --git a/src/services/CourseService.ts b/src/services/CourseService.ts
index acd0ffd..c8ab189 100644
--- a/src/services/CourseService.ts
+++ b/src/services/CourseService.ts
@@ -20,15 +20,17 @@ export class CourseService {
         this.lessonRepo = this.em.getRepository(Lesson) as LessonRepo;
     }
 
-    async getPaginatedCourses(filters: { languageCode?: string, addedBy?: string, searchQuery?: string }, sort: {
+    async getPaginatedCourses(filters: { languageCode?: string, addedBy?: string, searchQuery?: string, isBookmarked?: boolean }, sort: {
         sortBy: "title" | "createdDate" | "avgPastViewersCountPerLesson",
         sortOrder: "asc" | "desc"
     }, pagination: { page: number, pageSize: number }, user: User | AnonymousUser | null): Promise<[Course[], number]> {
         const dbFilters: FilterQuery<Course> = {$and: []};
 
-        if (user && user instanceof User)
+        if (user && user instanceof User) {
             dbFilters.$and!.push({$or: [{isPublic: true}, {addedBy: (user as User).profile}]});
-        else
+            if (filters.isBookmarked)
+                dbFilters.$and!.push({bookmarkers: user.profile});
+        } else
             dbFilters.$and!.push({isPublic: true});
 
         if (filters.languageCode !== undefined)
@@ -106,8 +108,8 @@ export class CourseService {
         }), {});
         const courseLessons = course.lessons.getItems();
         courseLessons.forEach(l => l.orderInCourse = idToOrder[l.id]);
-        this.courseRepo.persist(course);
-        this.lessonRepo.persist(courseLessons);
+        this.em.persist(course);
+        this.em.persist(courseLessons);
         await this.courseRepo.flush();
 
         return (await this.getCourse(course.id, user))!
diff --git a/tests/integration/courses.test.ts b/tests/integration/courses.test.ts
index ec38499..9b9a86f 100644
--- a/tests/integration/courses.test.ts
+++ b/tests/integration/courses.test.ts
@@ -30,6 +30,7 @@ import * as constantExports from "@/src/constants.js";
 import {TEMP_ROOT_FILE_UPLOAD_DIR} from "@/tests/testConstants.js";
 import {escapeRegExp} from "@/src/utils/utils.js";
 import {Profile} from "@/src/models/entities/Profile.js";
+import {MapBookmarkerCourse} from "@/src/models/entities/MapBookmarkerCourse.js";
 
 interface LocalTestContext extends TestContext {
     courseRepo: CourseRepo;
@@ -1550,3 +1551,452 @@ describe("PUT courses/:courseId/", function () {
         });
     });
 });
+
+
+/**{@link CourseController#getUserBookmarkedCourses}*/
+describe("GET user/me/courses/bookmarked/", function () {
+    const makeRequest = async (queryParams: object = {}, authToken?: string) => {
+        const options: InjectOptions = {
+            method: "GET",
+            url: `user/me/courses/bookmarked/${buildQueryString(queryParams)}`,
+        };
+        return await fetchRequest(options, authToken);
+    };
+    const queryDefaults = {pagination: {pageSize: 10, page: 1}};
+    const defaultSortComparator = createComparator(Course, [
+        {property: "title", order: "asc"},
+        {property: "id", order: "asc"}]
+    );
+    test<LocalTestContext>("If there are no filters return all courses user has bookmarked", async (context) => {
+        const user = await context.userFactory.createOne();
+        const session = await context.sessionFactory.createOne({user});
+
+        const language = await context.languageFactory.createOne();
+        const expectedCourses = await context.courseFactory.create(3, {language, bookmarkers: user.profile});
+        await context.courseFactory.create(3, {language});
+        await context.courseRepo.annotateVocabsByLevel(expectedCourses, user.profile.id)
+        expectedCourses.sort(defaultSortComparator);
+        const recordsCount = expectedCourses.length;
+
+        const response = await makeRequest({}, session.token);
+
+        expect(response.statusCode).to.equal(200);
+        expect(response.json()).toEqual({
+            page: queryDefaults.pagination.page,
+            pageSize: queryDefaults.pagination.pageSize,
+            pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+            data: courseSerializer.serializeList(expectedCourses)
+        });
+    });
+    describe("test languageCode filter", () => {
+        test<LocalTestContext>("If language filter is valid and language exists only return courses in that language that user has bookmarked", async (context) => {
+            const user = await context.userFactory.createOne();
+            const session = await context.sessionFactory.createOne({user});
+
+            const language1 = await context.languageFactory.createOne();
+            const language2 = await context.languageFactory.createOne();
+            const expectedCourses = await context.courseFactory.create(3, {language: language1, bookmarkers: user.profile});
+            await context.courseFactory.create(3, {language: language2, bookmarkers: user.profile});
+            await context.courseFactory.create(3, {language: language1});
+            await context.courseRepo.annotateVocabsByLevel(expectedCourses, user.profile.id)
+            expectedCourses.sort(defaultSortComparator);
+            const recordsCount = expectedCourses.length;
+
+            const response = await makeRequest({languageCode: language1.code}, session.token);
+
+            expect(response.statusCode).to.equal(200);
+            expect(response.json()).toEqual({
+                page: queryDefaults.pagination.page,
+                pageSize: queryDefaults.pagination.pageSize,
+                pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                data: courseSerializer.serializeList(expectedCourses)
+            });
+        });
+        test<LocalTestContext>("If language does not exist return empty course list", async (context) => {
+            const user = await context.userFactory.createOne();
+            const session = await context.sessionFactory.createOne({user});
+            await context.courseFactory.create(3, {language: await context.languageFactory.createOne(), bookmarkers: user.profile});
+
+            const response = await makeRequest({languageCode: faker.random.alpha({count: 4})}, session.token);
+            expect(response.statusCode).to.equal(200);
+            expect(response.json()).toEqual({
+                page: queryDefaults.pagination.page,
+                pageSize: queryDefaults.pagination.pageSize,
+                pageCount: 0,
+                data: []
+            });
+        });
+        test<LocalTestContext>("If language filter is invalid return 400", async (context) => {
+            const user = await context.userFactory.createOne();
+            const session = await context.sessionFactory.createOne({user});
+            const response = await makeRequest({languageCode: 12345}, session.token);
+            expect(response.statusCode).to.equal(400);
+        });
+    });
+    describe("test addedBy filter", () => {
+        test<LocalTestContext>("If addedBy filter is valid and user exists only return courses added by that user that current user has bookmarked", async (context) => {
+            const user = await context.userFactory.createOne();
+            const session = await context.sessionFactory.createOne({user});
+            const language = await context.languageFactory.createOne();
+
+            const user1 = await context.userFactory.createOne();
+            const user2 = await context.userFactory.createOne();
+            const expectedCourses = await context.courseFactory.create(3, {language, addedBy: user1.profile, bookmarkers: user.profile});
+            await context.courseFactory.create(3, {language, addedBy: user2.profile, bookmarkers: user.profile});
+            await context.courseFactory.create(3, {language, addedBy: user1.profile});
+            await context.courseRepo.annotateVocabsByLevel(expectedCourses, user.profile.id)
+            expectedCourses.sort(defaultSortComparator);
+            const recordsCount = expectedCourses.length;
+
+            const response = await makeRequest({addedBy: user1.username}, session.token);
+
+            expect(response.statusCode).to.equal(200);
+            expect(response.json()).toEqual({
+                page: queryDefaults.pagination.page,
+                pageSize: queryDefaults.pagination.pageSize,
+                pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                data: courseSerializer.serializeList(expectedCourses)
+            });
+        });
+        test<LocalTestContext>("If addedBy is me and signed in return courses added by current user that they have bookmarked", async (context) => {
+            const user = await context.userFactory.createOne();
+            const session = await context.sessionFactory.createOne({user});
+            const language = await context.languageFactory.createOne();
+
+            const otherUser = await context.userFactory.createOne();
+            const expectedCourses = await context.courseFactory.create(3, {language, addedBy: user.profile, bookmarkers: user.profile});
+            await context.courseFactory.create(3, {language, addedBy: otherUser.profile, bookmarkers: user.profile});
+            await context.courseFactory.create(3, {language, addedBy: user.profile});
+            await context.courseRepo.annotateVocabsByLevel(expectedCourses, user.profile.id)
+            expectedCourses.sort(defaultSortComparator);
+            const recordsCount = expectedCourses.length;
+
+            const response = await makeRequest({addedBy: "me"}, session.token);
+
+            expect(response.statusCode).to.equal(200);
+            expect(response.json()).toEqual({
+                page: queryDefaults.pagination.page,
+                pageSize: queryDefaults.pagination.pageSize,
+                pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                data: courseSerializer.serializeList(expectedCourses)
+            });
+        });
+        test<LocalTestContext>("If user does not exist return empty course list", async (context) => {
+            const user = await context.userFactory.createOne();
+            const session = await context.sessionFactory.createOne({user});
+            await context.courseFactory.create(3, {language: await context.languageFactory.createOne(), bookmarkers: user.profile});
+
+            const response = await makeRequest({addedBy: faker.random.alpha({count: 20})}, session.token);
+            expect(response.statusCode).to.equal(200);
+            expect(response.json()).toEqual({
+                page: queryDefaults.pagination.page,
+                pageSize: queryDefaults.pagination.pageSize,
+                pageCount: 0,
+                data: []
+            });
+        });
+        test<LocalTestContext>("If addedBy filter is invalid return 400", async (context) => {
+            const user = await context.userFactory.createOne();
+            const session = await context.sessionFactory.createOne({user});
+
+            const response = await makeRequest({addedBy: "!@#%#%^#^!"}, session.token);
+            expect(response.statusCode).to.equal(400);
+        });
+    });
+    describe("test searchQuery filter", () => {
+        test<LocalTestContext>("If searchQuery is valid return courses with query in title or description", async (context) => {
+            const user = await context.userFactory.createOne();
+            const session = await context.sessionFactory.createOne({user});
+            const language = await context.languageFactory.createOne();
+            const searchQuery = "search query";
+            const expectedCourses = [
+                await context.courseFactory.createOne({
+                    language,
+                    bookmarkers:user.profile
+                    title: `title ${randomCase(searchQuery)} ${faker.random.alphaNumeric(10)}`
+                }),
+                await context.courseFactory.createOne({
+                    language,
+                    description: `description ${randomCase(searchQuery)} ${faker.random.alphaNumeric(10)}`
+                })
+            ];
+            await context.courseFactory.create(3, {language: language});
+            expectedCourses.sort(defaultSortComparator);
+            const recordsCount = expectedCourses.length;
+
+            const response = await makeRequest({searchQuery: searchQuery});
+            expect(response.statusCode).to.equal(200);
+
+            expect(response.json()).toEqual({
+                page: queryDefaults.pagination.page,
+                pageSize: queryDefaults.pagination.pageSize,
+                pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                data: courseSerializer.serializeList(expectedCourses)
+            });
+        });
+        test<LocalTestContext>("If searchQuery is invalid return 400", async (context) => {
+            const response = await makeRequest({searchQuery: faker.random.alpha({count: 300})});
+
+            expect(response.statusCode).to.equal(400);
+        });
+        test<LocalTestContext>("If no courses match search query return empty list", async (context) => {
+            await context.courseFactory.create(3, {language: await context.languageFactory.createOne(), isPublic: true});
+
+            const response = await makeRequest({searchQuery: faker.random.alpha({count: 200})});
+
+            expect(response.statusCode).to.equal(200);
+            expect(response.json()).toEqual({
+                page: queryDefaults.pagination.page,
+                pageSize: queryDefaults.pagination.pageSize,
+                pageCount: 0,
+                data: []
+            });
+        });
+    });
+    describe("test sort", () => {
+        describe("test sortBy", () => {
+            test<LocalTestContext>("test sortBy title", async (context) => {
+                const language = await context.languageFactory.createOne();
+                const expectedCourses = [
+                    await context.courseFactory.createOne({title: "abc", isPublic: true, language}),
+                    await context.courseFactory.createOne({title: "def", isPublic: true, language})
+                ];
+                const recordsCount = expectedCourses.length;
+
+                const response = await makeRequest({sortBy: "title"});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: queryDefaults.pagination.page,
+                    pageSize: queryDefaults.pagination.pageSize,
+                    pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+            });
+            test<LocalTestContext>("test sortBy createdDate", async (context) => {
+                const language = await context.languageFactory.createOne();
+                const expectedCourses = [
+                    await context.courseFactory.createOne({addedOn: new Date("2018-07-22T10:30:45.000Z"), isPublic: true, language}),
+                    await context.courseFactory.createOne({addedOn: new Date("2023-03-15T20:29:42.000Z"), isPublic: true, language}),
+                ];
+                const recordsCount = expectedCourses.length;
+
+                const response = await makeRequest({sortBy: "createdDate"});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: queryDefaults.pagination.page,
+                    pageSize: queryDefaults.pagination.pageSize,
+                    pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+            });
+            test<LocalTestContext>("test sortBy avgPastViewersCountPerLesson", async (context) => {
+                const user1 = await context.userFactory.createOne();
+                const user2 = await context.userFactory.createOne();
+
+                const language = await context.languageFactory.createOne();
+                const expectedCourses = [
+                    await context.courseFactory.createOne({
+                        language,
+                        isPublic: true,
+                        lessons: []
+                    }),
+                    await context.courseFactory.createOne({
+                        language,
+                        isPublic: true,
+                        lessons: [context.lessonFactory.makeOne({pastViewers: []})]
+                    }),
+                    await context.courseFactory.createOne({
+                        language, isPublic: true,
+                        lessons: [context.lessonFactory.makeOne({pastViewers: [user1.profile]})]
+                    }),
+                    await context.courseFactory.createOne({
+                        language, isPublic: true,
+                        lessons: [context.lessonFactory.makeOne({pastViewers: [user1.profile, user2.profile]})]
+                    }),
+                ];
+                const recordsCount = expectedCourses.length;
+
+                const response = await makeRequest({sortBy: "avgPastViewersCountPerLesson"});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: queryDefaults.pagination.page,
+                    pageSize: queryDefaults.pagination.pageSize,
+                    pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+            });
+            test<LocalTestContext>("if sortBy is invalid return 400", async (context) => {
+                const response = await makeRequest({sortBy: "lessons"});
+                expect(response.statusCode).to.equal(400);
+            });
+        });
+        describe("test sortOrder", () => {
+            test<LocalTestContext>("test sortOrder ascending", async (context) => {
+                const language = await context.languageFactory.createOne();
+                const expectedCourses = [
+                    await context.courseFactory.createOne({title: "abc", isPublic: true, language}),
+                    await context.courseFactory.createOne({title: "def", isPublic: true, language})
+                ];
+                const recordsCount = expectedCourses.length;
+
+                const response = await makeRequest({sortOrder: "asc"});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: queryDefaults.pagination.page,
+                    pageSize: queryDefaults.pagination.pageSize,
+                    pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+            });
+            test<LocalTestContext>("test sortOrder descending", async (context) => {
+                const language = await context.languageFactory.createOne();
+                const expectedCourses = [
+                    await context.courseFactory.createOne({title: "def", isPublic: true, language}),
+                    await context.courseFactory.createOne({title: "abc", isPublic: true, language}),
+                ];
+                const recordsCount = expectedCourses.length;
+
+                const response = await makeRequest({sortOrder: "desc"});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: queryDefaults.pagination.page,
+                    pageSize: queryDefaults.pagination.pageSize,
+                    pageCount: Math.ceil(recordsCount / queryDefaults.pagination.pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+            });
+            test<LocalTestContext>("if sortBy is invalid return 400", async (context) => {
+                const response = await makeRequest({sortOrder: "rising"});
+                expect(response.statusCode).to.equal(400);
+            });
+        });
+    });
+    describe("test pagination", () => {
+        describe("test page", () => {
+            test<LocalTestContext>("If page is 1 return the first page of results", async (context) => {
+                const allCourses = await context.courseFactory.create(10, {language: await context.languageFactory.createOne()});
+                allCourses.sort(defaultSortComparator);
+                const recordsCount = allCourses.length;
+                const page = 1, pageSize = 3;
+                const expectedCourses = allCourses.slice(pageSize * (page - 1), pageSize * (page - 1) + pageSize);
+
+                const response = await makeRequest({page, pageSize});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: page,
+                    pageSize: pageSize,
+                    pageCount: Math.ceil(recordsCount / pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+            });
+            test<LocalTestContext>("If page is 2 return the second page of results", async (context) => {
+                const allCourses = await context.courseFactory.create(10, {language: await context.languageFactory.createOne()});
+                allCourses.sort(defaultSortComparator);
+                const recordsCount = allCourses.length;
+                const page = 2, pageSize = 3;
+                const expectedCourses = allCourses.slice(pageSize * (page - 1), pageSize * (page - 1) + pageSize);
+
+                const response = await makeRequest({page, pageSize});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: page,
+                    pageSize: pageSize,
+                    pageCount: Math.ceil(recordsCount / pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+            });
+            test<LocalTestContext>("If page is last return the last page of results", async (context) => {
+                const allCourses = await context.courseFactory.create(10, {language: await context.languageFactory.createOne()});
+                allCourses.sort(defaultSortComparator);
+                const recordsCount = allCourses.length;
+                const pageSize = 3;
+                const page = Math.ceil(recordsCount / pageSize);
+                const expectedCourses = allCourses.slice(pageSize * (page - 1), pageSize * (page - 1) + pageSize);
+
+                const response = await makeRequest({page, pageSize});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: page,
+                    pageSize: pageSize,
+                    pageCount: Math.ceil(recordsCount / pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+            });
+            test<LocalTestContext>("If page is more than last return empty page", async (context) => {
+                const allCourses = await context.courseFactory.create(10, {language: await context.languageFactory.createOne()});
+                const recordsCount = allCourses.length;
+                const pageSize = 3;
+                const page = Math.ceil(recordsCount / pageSize) + 1;
+                const expectedCourses = allCourses.slice(pageSize * (page - 1), pageSize * (page - 1) + pageSize);
+
+                const response = await makeRequest({page, pageSize});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: page,
+                    pageSize: pageSize,
+                    pageCount: Math.ceil(recordsCount / pageSize),
+                    data: []
+                });
+            });
+            describe("If page is invalid return 400", () => {
+                test<LocalTestContext>("If page is less than 1 return 400", async (context) => {
+                    const response = await makeRequest({page: 0, pageSize: 3});
+
+                    expect(response.statusCode).to.equal(400);
+                });
+                test<LocalTestContext>("If page is not a number return 400", async (context) => {
+                    const response = await makeRequest({page: "last", pageSize: 3});
+
+                    expect(response.statusCode).to.equal(400);
+                });
+            });
+        });
+        describe("test pageSize", () => {
+            test<LocalTestContext>("If pageSize is 20 split the results into 20 sized pages", async (context) => {
+                const language = await context.languageFactory.createOne();
+                const allCourses = await context.courseFactory.create(50, {language});
+                allCourses.sort(defaultSortComparator);
+                const recordsCount = allCourses.length;
+                const page = 2, pageSize = 20;
+                const expectedCourses = allCourses.slice(pageSize * (page - 1), pageSize * (page - 1) + pageSize);
+
+                const response = await makeRequest({page, pageSize});
+
+                expect(response.statusCode).to.equal(200);
+                expect(response.json()).toEqual({
+                    page: page,
+                    pageSize: pageSize,
+                    pageCount: Math.ceil(recordsCount / pageSize),
+                    data: courseSerializer.serializeList(expectedCourses)
+                });
+                expect(response.json().data.length).toBeLessThanOrEqual(pageSize);
+            });
+            describe("If pageSize is invalid return 400", () => {
+                test<LocalTestContext>("If pageSize is too big return 400", async (context) => {
+                    const response = await makeRequest({page: 1, pageSize: 250});
+
+                    expect(response.statusCode).to.equal(400);
+                });
+                test<LocalTestContext>("If pageSize is negative return 400", async (context) => {
+                    const response = await makeRequest({page: 1, pageSize: -20});
+
+                    expect(response.statusCode).to.equal(400);
+                });
+                test<LocalTestContext>("If pageSize is not a number return 400", async (context) => {
+                    const response = await makeRequest({page: 1, pageSize: "a lot"});
+
+                    expect(response.statusCode).to.equal(400);
+                });
+            });
+        });
+    });
+});
